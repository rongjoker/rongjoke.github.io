## 一次别离

### 告别两年以来的自己
&#160; &#160; &#160; &#160;我的MacBook，自18年入职以来一直使用的MacBook，深空灰、蝶式键盘、16GB的RAM、1TB的ROM、可以登陆icloud的MacBook，我编写了无数行代码、学习过无数教程和知识的MacBook，戏虐地贴满了Google event斩获的各种谷歌家贴纸的MacBook，于国庆前屏幕挂掉。经过各种周转，邮寄到总部修理，it给我另外一台备用，承允我数日之内即可修好。然而就在昨天，国庆后没几天，it老大来电告知屏幕修理需要3000元，不值当修理，决定留在总部配一台显示器来使用。而我的这台备胎转正。
<br/>
&#160; &#160; &#160; &#160;早知是最后一面，我会好好的告别。
<br/>
### 科技圈春晚
&#160; &#160; &#160; &#160;再过几个小时，Apple的秋季第二场发布会就要开始。我的那台iphone 6SP，自15年10月发布之日起即购买，用到如今超过5年，相当于小学二年级到小学毕业进入中学的时间长度，眼看即将退役。相比前几个月暴热的天气，它各种发烫卡顿，现在来说已经流畅很多。除了换两块电池依然续航惨不忍睹外，我居然找不到换机的理由。6SP在今年早些时间升级ios14 beta版本后，依然剑形如飞，一如之前率先升级ios12和ios13，也正是因此，我屡次决定换成xs和11，都忍住了。一台陪伴自己5年，摔了无数次，自己动手修过摄像头、换过电池的手机，的确是有感情了。
&#160; &#160; &#160; &#160;24日，下单了iphone12。
### Dijkstra 和 Floyd 
&#160; &#160; &#160; &#160;数据结构中，图大概是最难学的，图中又以狄杰斯特拉和佛洛依德两个算法最难。讽刺的是，数据结构涉及到的各种常规算法，又以这两种最为短小，佛洛依德甚至可以说只有四行代码。

```
for ( int k = 1 ; k <= n ; k ++  )
    for ( int i = 1 ; i <= n ; i ++  )
        for ( int j = 1 ; j <= n ; j ++  )
            if ( d[i][j] > d[i][k] + d[k][j] )d[i][j] = d[i][k] + d[k][j];

```

不学这两种算法，感觉数据结构学得不完整；学这两种算法吧，很容易给自己挖一个大坑。毕竟狄杰斯特拉本质是贪心，佛洛依德本质是动态规划。
<p align="center">
  <img src="https://s1.ax1x.com/2020/10/26/BuoAWn.png" alt="dp">
</p>
&#160; &#160; &#160; &#160;在不打ACM的普通程序员眼中，妥妥的两大最难算法。关键的，这两个算法的发明者都是巨佬级别。狄杰斯特拉最出名的可能还不是最短路径，而是解决了哲学家就餐的死锁问题；佛洛依德亦是纸面性能强大实际没什么卵用（狗头）的堆排序的提出者。不学岂不是摔祖师爷的饭碗？
