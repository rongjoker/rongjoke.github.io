---
layout: post
title: 最近看的一些书
---

多余的话
redis
### 位运算
位运算算是leetcode各类算法里最奇妙的一种，它能解决的问题，一般来说，用其他方法也能解决，只是两种方法对比效率，位运算会优秀极多。同时，位运算的解题也折射出高中数学以及部分大学高等数学的思想。<br>


### 只出现一次的数字
leetcode各种系列中，以`只出现一次的数字`系列最鲜为人知。这类题目基本都可以用hashset解决，所以即使题目暗示、明示了用位运算，实际解题者也都以set简单跳过。原因无他，只是位运算在面试中出现的可能性极小。系列三个题目均可以用位运算解决，第一题最简单，数组依次亦或运算即可。第二题较难，利用了位运算解题常见的一种思路：把一个数字放在定长（往往是32）的二进制树上进行逐个位子的运算，最终得到结果。<br>
 第三题[260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/) 难度要高出不少。前两题仅要求解出一个数字，这个题目要求解出2个数字。其实思路反而和第一个题目一致，即把数组分为2部分，分别亦或运算即可得到2个数字。不过能识别出两个数字的特征是难点。大部分位运算用到的是亦或。这一步却用到与运算。利用与运算找到第一个不同的位数(亦或运算完为1则说明不同，只要找到与1与运算不为0的那个位数即是亦或结果为1也就是2个数字不同的地方)。随后将整个数组依次进行与运算，得到0和1的即是两个子数组部分，逐位亦或即可。<br>
```
                    int[] ans = new int[2];

        int k = 0;
        for (int num:nums)
            k ^= num;
        int div = 1;
        while ((div & k) == 0)
            div <<= 1;
        for(int num:nums){
            if ((num & div) == 0)
                ans[0] ^= num;
            else
                ans[1] ^= num;
        }

        return ans;
```
